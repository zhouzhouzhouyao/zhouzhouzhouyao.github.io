
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小周的魔法圣诞树</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            /* 为了保险，先用通用字体，防止谷歌字体加载失败，实际部署可以换回高级字体 */
            font-family: 'Times New Roman', serif; 
            /* 防止移动端双击缩放和长按选中 */
            touch-action: none;
            user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 5%;
            left: 0;
            width: 100%;
            text-align: center;
            color: #e6c77f;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-weight: 400;
            letter-spacing: 0.2em;
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(230, 199, 127, 0.5);
        }

        .subtitle {
            font-size: 0.8rem;
            letter-spacing: 0.3em;
            margin-top: 15px;
            opacity: 0.8;
        }
        
        .subtitle::before, .subtitle::after {
            content: "—";
            margin: 0 10px;
            opacity: 0.5;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e6c77f;
            font-size: 1.2rem;
            z-index: 20;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">小周正在加载圣诞魔法...<br><span style="font-size:12px; opacity:0.6">(首次加载可能需要几秒钟)</span></div>

    <div id="ui-overlay">
        <h1>MERRY CHRISTMAS</h1>
        <div class="subtitle">For K</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, controls, composer;
        let particles = [];
        let isExploded = false;
        
        // 用于区分拖拽和点击的变量
        let pointerDownX = 0;
        let pointerDownY = 0;
        const CLICK_MOVE_THRESHOLD = 10; // 允许的最大移动像素值，超过则认为是拖拽

        const params = {
            particleCount: 1800,
            treeHeight: 60,
            treeRadius: 25,
            explodeRadius: 120,
            lerpSpeed: 0.04
        };

        const colors = {
            gold: new THREE.Color(0xffd700),
            red: new THREE.Color(0xc41e3a),
            green: new THREE.Color(0x2e4a3d),
            emissiveGold: new THREE.Color(0xffeb99)
        };

        window.addEventListener('error', (e) => {
            const loading = document.getElementById('loading');
            loading.innerHTML = "加载失败<br>请检查网络配置";
            loading.style.color = "#ff6b6b";
        });

        init();
        animate();

        function init() {
            try {
                const container = document.getElementById('canvas-container');
                
                // 1. 场景
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.002);

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 30, 100);

                // 2. 渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                container.appendChild(renderer.domElement);

                // 3. 控制器
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
                controls.maxPolarAngle = Math.PI / 1.5;

                // 4. 灯光
                const ambientLight = new THREE.AmbientLight(0x444444);
                scene.add(ambientLight);
                const mainLight = new THREE.PointLight(colors.gold, 2, 200);
                mainLight.position.set(20, 50, 20);
                scene.add(mainLight);
                const secondaryLight = new THREE.PointLight(colors.red, 1.5, 200);
                secondaryLight.position.set(-20, 10, -20);
                scene.add(secondaryLight);
                const dirLight = new THREE.DirectionalLight(0xffeedd, 1);
                dirLight.position.set(0, 100, 50);
                scene.add(dirLight);

                // 5. 粒子
                createParticles();
                createStarfield();

                // 6. 后期处理 (辉光)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.1);
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                window.addEventListener('resize', onWindowResize);

                // Let user control audio
                // --- 关键修改：优化交互逻辑，区分点击和拖拽 ---

                // 记录按下时的坐标 (兼容鼠标和触摸)
                renderer.domElement.addEventListener('pointerdown', (event) => {
                    pointerDownX = event.clientX;
                    pointerDownY = event.clientY;
                });

                // 松开时判断移动距离
                renderer.domElement.addEventListener('pointerup', (event) => {
                    // 计算按下和松开之间的距离
                    const moveX = Math.abs(event.clientX - pointerDownX);
                    const moveY = Math.abs(event.clientY - pointerDownY);

                    // 如果移动距离很小（小于阈值），则认为是点击，触发交互
                    if (moveX < CLICK_MOVE_THRESHOLD && moveY < CLICK_MOVE_THRESHOLD) {
                        toggleState();
                    }
                    // 如果移动距离大，则认为是拖拽OrbitControls，不触发 toggleState
                });

                // 移除旧的简单 click 监听
                // renderer.domElement.addEventListener('click', toggleState); // 已移除

                // --- 修改结束 ---

                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => {
                    if(document.getElementById('loading')) document.getElementById('loading').style.display = 'none';
                }, 500);

            } catch (err) {
                console.error("Init Error:", err);
            }
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
            const starVertices = [];
            for (let i = 0; i < 2000; i++) {
                starVertices.push((Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function getMaterials() {
            const matGold = new THREE.MeshStandardMaterial({ color: colors.gold, metalness: 0.9, roughness: 0.2 });
            const matGreen = new THREE.MeshStandardMaterial({ color: colors.green, metalness: 0.1, roughness: 0.8 });
            const matRed = new THREE.MeshStandardMaterial({ color: colors.red, metalness: 0.4, roughness: 0.5 });
            const matEmissive = new THREE.MeshStandardMaterial({ color: colors.gold, emissive: colors.emissiveGold, emissiveIntensity: 2.0, toneMapped: false });
            return [matGold, matGreen, matRed, matEmissive];
        }

        function getGeometries() {
            return {
                sphere: new THREE.SphereGeometry(1, 16, 16),
                box: new THREE.BoxGeometry(1.5, 1.5, 1.5),
                cane: new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                tinySphere: new THREE.SphereGeometry(0.4, 8, 8)
            };
        }

        function createParticles() {
            const mats = getMaterials();
            const geoms = getGeometries();

            for (let i = 0; i < params.particleCount; i++) {
                let mesh, mat;
                const randType = Math.random();
                if (randType < 0.15) mesh = new THREE.Mesh(geoms.cane, Math.random() > 0.5 ? mats[2] : mats[0]);
                else if (randType < 0.4) mesh = new THREE.Mesh(geoms.box, Math.random() > 0.5 ? mats[0] : mats[1]);
                else if (randType < 0.7) {
                    const colorRand = Math.random();
                    mat = colorRand < 0.33 ? mats[0] : (colorRand < 0.66 ? mats[1] : mats[2]);
                    mesh = new THREE.Mesh(geoms.sphere, mat);
                    const scale = 0.8 + Math.random() * 0.8;
                    mesh.scale.set(scale, scale, scale);
                } else mesh = new THREE.Mesh(geoms.tinySphere, mats[3]);

                const p = i / params.particleCount;
                const y = p * params.treeHeight;
                const radiusAtHeight = params.treeRadius * (1 - p);
                const theta = p * Math.PI * 20 + Math.random() * Math.PI * 2;
                
                const targetX = (radiusAtHeight + (Math.random()-0.5)*3) * Math.cos(theta);
                const targetY = y - params.treeHeight / 2;
                const targetZ = (radiusAtHeight + (Math.random()-0.5)*3) * Math.sin(theta);
                
                mesh.userData.treePos = new THREE.Vector3(targetX, targetY, targetZ);
                mesh.userData.treeRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                const phi = Math.acos(-1 + (2 * i) / params.particleCount);
                const thetaSphere = Math.sqrt(params.particleCount * Math.PI) * phi;
                mesh.userData.explodedPos = new THREE.Vector3(
                    params.explodeRadius * Math.cos(thetaSphere) * Math.sin(phi) * (0.5 + Math.random()),
                    params.explodeRadius * Math.sin(thetaSphere) * Math.sin(phi) * (0.5 + Math.random()),
                    params.explodeRadius * Math.cos(phi) * (0.5 + Math.random())
                );
                
                mesh.position.copy(mesh.userData.treePos);
                mesh.rotation.copy(mesh.userData.treeRot);
                mesh.userData.spinSpeed = new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02);
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function toggleState() {
            isExploded = !isExploded;
            controls.autoRotate = false;
            setTimeout(() => { controls.autoRotate = true; }, 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            particles.forEach(mesh => {
                let targetPos;
                if (isExploded) {
                    targetPos = mesh.userData.explodedPos;
                    mesh.rotation.x += mesh.userData.spinSpeed.x;
                    mesh.rotation.y += mesh.userData.spinSpeed.y;
                    mesh.rotation.z += mesh.userData.spinSpeed.z;
                } else {
                    targetPos = mesh.userData.treePos;
                     mesh.rotation.x += (mesh.userData.treeRot.x - mesh.rotation.x) * params.lerpSpeed * 0.5;
                     mesh.rotation.y += (mesh.userData.treeRot.y - mesh.rotation.y) * params.lerpSpeed * 0.5;
                     mesh.rotation.z += (mesh.userData.treeRot.z - mesh.rotation.z) * params.lerpSpeed * 0.5;
                }
                mesh.position.lerp(targetPos, params.lerpSpeed);
            });
            composer.render();
        }
    </script>
</body>
</html>